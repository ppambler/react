### ✍️ Tangxt ⏳ 2020-12-25 🏷️ 诞生

# 01-React 的诞生

## ★课件

代码：<http://jsbin.com/piwazag/1/edit?html,js,output>

1. React 的初衷？
2. createElement
3. JSX
4. [Babel Online](https://babeljs.io/repl#?babili=false&browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=DwEwlgbgBAxgNgQwM5ILwHIAOCBOBTAOwBd0A-AKCiqmCWwNkRQ3xDIG8CBXAWwCM8OAL7AA9HQQEK1Gny5EiAewbKAwnDAwA1qnZqN2gELylBIaQDUYuQuXTqwG6aj7NOvQXVvjtggCZzAFprEztyMXAIUiA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=false&presets=es2015%2Ces2016%2Ces2017%2Creact%2Cstage-0%2Cstage-1%2Cstage-2%2Cstage-3%2Ces2015-loose%2Cenv&prettier=true&targets=&version=6.26.0&envVersion=1.6.2)

![React 做了什么](assets/img/2020-12-25-15-54-25.png)

## ★React 的诞生

> 为什么说 React 是先进的、生产力的代表？

React 最重要的一个东西，就是关于 `createElement` 这部分内容！

1）原生 JS

需求：加 1 减 1

![加 1 减 1](assets/img/2020-12-27-17-00-16.png)

完成这个需求，显然需要用到 DOM API，如需要获取元素等……之后，你用了 React ，你就会明白你被颠覆了……

代码实现：

![代码 1](assets/img/2020-12-27-17-31-17.png)

用图表示以上代码在干什么……

**程序最重要的两个能力，一个是理解力，另一个就是抽象**。你需要把上述的运行结果这样具体的东西，抽象成不具体的东西

抽象的反义词就是具体，而我们不需要具体，我们要的是「抽象」

那如何抽象呢？

简单回顾整个代码运行逻辑，我们可以把整个过程，分为两块：

* 页面
* JS

我们透过 `innerText` 从页面中把数据提取到 JS 中，然后通过那两个 `+1/-1` 按钮，还是透过 `innerText = ` 把数据回填到页面中！

这个代码运行逻辑并不复杂，但有点烦

![一来一回](assets/img/2020-12-27-17-44-45.png)

总之，我们完成这个需求，总得做这一步：「获取页面数据，改数据，回填数据到页面」，这一步是无法省略的，而这就是 DOM 提供的方法了！

然而写 React 的程序员，也就是作者，觉得这个过程太智障了，虽然代码挺简单的，但就是很不爽……

话说，有咩有一种更简便的方法呢？

可以这样做：把上边的 `innerText` 干掉，而下边的 `innerText=` 不能干掉，不然 JS 就无法通知页面改数据了！

![不取只填](assets/img/2020-12-27-18-00-36.png)

带着这样的理念，React 就诞生了……

接下来，我们抱着这种理念，使用 React 重写这个需求！

2）React 初使用

cdn 引用两个库：

* react
* react-dom

> 选择 umd（Universal Module Definition）是 AMD 和 CommonJS 的糅合，跨平台（浏览器 & 服务端）的解决方案

💡：为什么需要依赖两个库？

React 是一个非常厉害的库，Facebook 的牛人写的。它能**让页面更可控，性能极高，而且使用起来很简单**。

**React DOM 是用来操作 DOM 的**，因为这些 DOM 是用 JSX 写的，所以需要一个专门的库来操作。

JSX 是对 JS 的扩展，它看起来跟 XML 差不多，可以用来写 HTML，你**可以认为 JSX 是一种更优雅的 HTML 写法**。

➹：[在 2016 年学 JavaScript 是一种什么样的体验？ - 知乎](https://zhuanlan.zhihu.com/p/22782487)

---

之前说到，页面是咩有东西的，即你不用写这个了：

![页面结构](assets/img/2020-12-27-18-51-49.png)

所以此时的页面结构，直接这样：

``` html
<div id="app"></div>
```

就行了……

完整代码：

``` html
<div id="app" class="container">
</div>
<button id="add" class="button is-primary"> + </button>
<button id="minus" class="button is-primary"> - </button>
<script src="https://cdn.bootcdn.net/ajax/libs/react/17.0.1/umd/react.development.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/react-dom/17.0.1/umd/react-dom.development.min.js"></script>
<script>
  let number = 0
  let span = React.createElement('span', {
    className: 'tag'
  }, number)
  ReactDOM.render(span, document.querySelector("#app"))

  let add = document.querySelector('#add')
  add.onclick = () => {
    number += 1
    let span = React.createElement('span', {
      className: 'tag'
    }, number)
    ReactDOM.render(span, document.querySelector("#app"))
  }
  let minus = document.querySelector('#minus')
  minus.onclick = () => {
    number -= 1
    let span = React.createElement('span', {
      className: 'tag'
    }, number)
    ReactDOM.render(span, document.querySelector("#app"))
  }
</script>
```

效果：

![react 101](assets/img/2020-12-27-19-46-40.png)

总之，根据之前那张图，**只有从 JS 到页面这个过程，没有页面到 JS 这个过程！**

当然，目前的代码还是很傻的！不过，你至少有了**这种想法「只有从 JS 到页面的过程」**

优化一下代码（我与重复不共戴天）：

``` js
let number = 0
render()

let add = document.querySelector('#add')
add.onclick = () => {
  number += 1
  render()
}
let minus = document.querySelector('#minus')
minus.onclick = () => {
  number -= 1
  render()
}

function render() {
  let span = React.createElement('span', {
    className: 'tag'
  }, number)
  ReactDOM.render(span, document.querySelector("#app"))
}
```

`number`为`0`就`render`一下，`number`为`1`就`render`一下……`number`变了就`render`一下！

可以看到，我们要做的就只有把`number`的值改一下，然后`render`一下，除此之外，不做任何事……

以上就是 React 的所有操作了，除此之外，没有任何操作！

可以看到，React 的操作，让我们不用去理会取元素的儿子、爸爸、爷爷等复杂繁琐的操作了……

3）把按钮放到`#app`容器里边

要点：

- 事件监听怎么做？
- 同级多个元素怎么做？

代码：

``` html
<div id="app" class="container">
</div>
<script src="https://cdn.bootcdn.net/ajax/libs/react/17.0.1/umd/react.development.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/react-dom/17.0.1/umd/react-dom.development.min.js"></script>
<script>
 let number = 0
 let onClickButton = ()=>{
   number += 1
   render()
 }
 let onClickButton2 = ()=>{
   number -= 1
   render()
 }

 render()

 function render() {
  let span = React.createElement('span',{className:'tag'},number)
  let button = React.createElement('button',{onClick:onClickButton,className:'button is-primary'},'+')
  let button2 = React.createElement('button',{onClick:onClickButton2,className:'button is-primary'},'-')
  let div = React.createElement('div',{className:"parent"},span,button,button2)
  ReactDOM.render(div,document.querySelector("#app"))
 }
</script>
```

效果：

![效果](assets/img/2020-12-27-20-59-31.png)

> 不会全局更新，只会局部更新，哪里变化了，就会更新哪里！

可以看到整个页面内容，都是 JS 渲染的！而 React 的存在，简化了我们要写的很多代码，而且这性能要比我们自己用原生 DOM API 要高效得多！

对比我们之前的原生 JS 代码，用了 React，显然让代码更简洁、更易懂了……

小结：

- 数据变化，就`render`，数据变化，就`render`……结合一开始那个草稿图来理解……

接下来，对这个`render`函数来一个更深层次的优化！

💡：在 HTML 元素上写`click`事件？

``` html
<button onclick="myFunction()">Click me</button>
```

➹：[HTML onclick Event Attribute](https://www.w3schools.com/tags/ev_onclick.asp)

💡：在 React 中，如何写多个`class`，是用`classList`吗？

直接`{className: 'class1 class2'}`就好了！

➹：[javascript - Toggle Class in React - Stack Overflow](https://stackoverflow.com/questions/36403101/toggle-class-in-react)

💡：我在`div#app`写了一个`<div>hi</div>`，你觉得这个元素户会被渲染吗？

结果并咩有被渲染！`ReactDOM.render(div,document.querySelector("#app"))`这个操作，把`div#app`旗下的内容都给覆盖了，该`render`API 的实现，并不是`appendChild`，而是类似于`innerHTML` 这样

## ★jsx 的发明
