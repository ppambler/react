### ✍️ Tangxt ⏳ 2021-03-13 🏷️ React

# 02-React 类组件和函数组件

## ★元素 vs 组件

1）元素与组件

![元素与组件](assets/img/2021-03-15-11-10-46.png)

2）什么是组件？

![组件](assets/img/2021-03-15-11-13-12.png)

- 就目前的 React 版本而言，一个返回了 React 元素的**函数**就是**组件**
- 而 Vue -> 一个构造选项即一个组件

3）React 两种组件

函数组件：

![函数组件](assets/img/2021-03-15-11-18-29.png)

类组件：

![类组件](assets/img/2021-03-15-11-20-45.png)

## ★标签会被翻译为 `React.createElement`

1）Welcome 标签

![Welcome](assets/img/2021-03-16-11-54-37.png)

如：

![babel-online](assets/img/2021-03-16-11-57-59.png)

2）`React.createElement` 的逻辑

![react 元素](assets/img/2021-03-16-12-03-39.png)

题外话：写类组件是很麻烦的，因为每次你都得写一些很固定的东西：

![类组件](assets/img/2021-03-16-12-11-43.png)

## ★小试牛刀，请动手尝试

需求：

1. div -> 爸爸 -> `Father`组件
   1. div -> 儿子 -> `Son`组件
      1. button -> +1 -> n+1
      2. span -> n
      3. div -> 孙子 -> `Grandson`组件
         1. button -> +1 -> n+1
         2. span -> n

实现：

``` jsx
import React from "react";
import ReactDOM from "react-dom";

import "./styles.css";

function App() {
  return (
    <div className="App">
      爸爸
      <Son />
    </div>
  );
}

// 儿子组件
class Son extends React.Component {
  constructor() {
    super();
    this.state = {
      n: 0
    };
  }
  add() {
    // this.state.n += 1 为什么不行
    this.setState({ n: this.state.n + 1 });
  }
  render() {
    return (
      <div className="Son">
        儿子 n: {this.state.n}
        <button onClick={() => this.add()}>+1</button>
        <Grandson />
      </div>
    );
  }
}

// 孙子组件
const Grandson = () => {
  const [n, setN] = React.useState(0);
  return (
    <div className="Grandson">
      孙子 n:{n}
      <button onClick={() => setN(n + 1)}>+1</button>
    </div>
  );
};

//获取页面上需要渲染的位置
const rootElement = document.getElementById("root");
ReactDOM.render(<App />, rootElement);
```

解析：

App 组件：

![App 组件](assets/img/2021-03-16-13-20-42.png)

Son 组件：

![Son 组件](assets/img/2021-03-16-13-23-02.png)

Grandson 组件：

![孙子组件](assets/img/2021-03-16-13-24-30.png)

Grandson 的原理：

`0` 就是 `state` 的初始值

这行代码：

``` js
const [n, setN] = React.useState(0)
```

等价于：

``` js
const array = React.useState(0)
const n = array[0]
const setN = array[1]
```

我们用了析构写法：声明一个`state`初始值为 `0`，用 `n` 代表 `0`，用 `setN` 去对 `0` 进行修改（对一个变量的读和写操作）

注意：

> `setN`之后得到的是一个新的`n`，而不是改变原有的`n`

💡：为什么`const`声明的变量`n`能被改值？`setN`到底做了什么？

![const 变量](assets/img/2021-03-16-13-47-09.png)

➹：[为什么useState可以使用const解构赋值？_高桥靓仔的博客-CSDN博客](https://blog.csdn.net/weixin_45221036/article/details/108581908)

➹：[useState 的原理及模拟实现 —— React Hooks 系列（一） - 知乎](https://zhuanlan.zhihu.com/p/100714485)

## ★类组件和函数组件使用 `props`

1）添加 props（外部数据）

![props](assets/img/2021-03-16-17-20-18.png)

``` jsx
import React from "react";
import ReactDOM from "react-dom";

import "./styles.css";

function App() {
  return (
    <div className="App">
      爸爸
      <Son messageForSon="儿子你好" />
    </div>
  );
}

class Son extends React.Component {
  render() {
    return (
      <div className="Son">
        我是儿子，我爸对我说「{this.props.messageForSon}」
        <Grandson messageForGrandson="孙贼你好" />
      </div>
    );
  }
}

const Grandson = props => {
  return (
    <div className="Grandson">
      我是孙子，我爸对我说「{props.messageForGrandson}」
    </div>
  );
};

const rootElement = document.getElementById("root");
ReactDOM.render(<App />, rootElement);
```

效果：

![效果](assets/img/2021-03-16-17-26-02.png)

解析：

💡：爸爸组件如何传数据给儿子？

直接在儿子组件标签上写属性：

![属性](assets/img/2021-03-16-17-24-18.png)

值是字符串，那就是`"xxx"`，如果是变量，那就`{xxx}`

💡：儿子怎么接收爸爸传过来的数据？

类组件直接用`this.props.xxx`：

![类组件](assets/img/2021-03-16-17-29-44.png)

函数组件则是「第一个参数的`xxx`」：

![函数组件](assets/img/2021-03-16-17-32-23.png)

> 也可以用析构语法`{xxx}`

## ★类组件和函数组件使用 `state`（内部数据）

> 传递的是内部数据 -> `state` -> 遵守不可变数据理论！





